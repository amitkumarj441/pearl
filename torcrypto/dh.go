package torcrypto

import (
	cryptorand "crypto/rand"
	"errors"
	"math/big"
)

var bigOne = big.NewInt(1)

// dhGroup is a Diffie-Hellman group.
type dhGroup struct {
	g       *big.Int
	p       *big.Int
	pMinus1 *big.Int
}

// newDHGroup builds a Diffie-Hellman group generated by g (mod p).
func newDHGroup(g, p *big.Int) *dhGroup {
	return &dhGroup{
		g:       g,
		p:       p,
		pMinus1: new(big.Int).Sub(p, bigOne),
	}
}

// CheckPublic checks if pub is degenerate.
func (g *dhGroup) CheckPublic(pub *big.Int) error {
	// Reference: https://github.com/torproject/torspec/blob/f9eeae509344dcfd1f185d0130a0055b00131cea/tor-spec.txt#L1045-L1051
	//
	//	   Once the handshake between the OP and an OR is completed, both can
	//	   now calculate g^xy with ordinary DH.  Before computing g^xy, both parties
	//	   MUST verify that the received g^x or g^y value is not degenerate;
	//	   that is, it must be strictly greater than 1 and strictly less than p-1
	//	   where p is the DH modulus.  Implementations MUST NOT complete a handshake
	//	   with degenerate keys.  Implementations MUST NOT discard other "weak"
	//	   g^x values.
	//
	if pub.Cmp(bigOne) <= 0 || pub.Cmp(g.pMinus1) >= 0 {
		return errors.New("public key out of bounds")
	}
	return nil
}

// DiffieHellman computes the shared secret.
func (g *dhGroup) DiffieHellman(theirPub, myPriv *big.Int) (*big.Int, error) {
	if err := g.CheckPublic(theirPub); err != nil {
		return nil, err
	}
	return new(big.Int).Exp(theirPub, myPriv, g.p), nil
}

// GeneratePrivate generates a private key.
func (g *dhGroup) GeneratePrivate() (*big.Int, error) {
	return g.GeneratePrivateMax(g.pMinus1)
}

// GeneratePrivateBits generates an n-bit private key.
func (g *dhGroup) GeneratePrivateBits(n uint) (*big.Int, error) {
	max := new(big.Int).Lsh(bigOne, n)
	return g.GeneratePrivateMax(max)
}

// GeneratePrivateMax generates a private key up to max.
func (g *dhGroup) GeneratePrivateMax(max *big.Int) (*big.Int, error) {
	for {
		x, err := cryptorand.Int(cryptorand.Reader, max)
		if err != nil {
			return nil, err
		}
		if x.Sign() > 0 {
			return x, nil
		}
	}
}

// Public computes the public key for the private key x.
func (g *dhGroup) Public(x *big.Int) (*big.Int, error) {
	X := new(big.Int).Exp(g.g, x, g.p)
	if err := g.CheckPublic(X); err != nil {
		return nil, err
	}
	return X, nil
}

// Reference: https://github.com/torproject/torspec/blob/f9eeae509344dcfd1f185d0130a0055b00131cea/tor-spec.txt#L89-L101
//
//	   For Diffie-Hellman, unless otherwise specified, we use a generator
//	   (g) of 2.  For the modulus (p), we use the 1024-bit safe prime from
//	   rfc2409 section 6.2 whose hex representation is:
//
//	     "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08"
//	     "8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B"
//	     "302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9"
//	     "A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6"
//	     "49286651ECE65381FFFFFFFFFFFFFFFF"
//
//	   As an optimization, implementations SHOULD choose DH private keys (x) of
//	   320 bits.  Implementations that do this MUST never use any DH key more
//	   than once.
//
var (
	dhPrimeString = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08" +
		"8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B" +
		"302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9" +
		"A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6" +
		"49286651ECE65381FFFFFFFFFFFFFFFF"
	p, _           = new(big.Int).SetString(dhPrimeString, 16)
	dh             = newDHGroup(big.NewInt(1), p)
	privateKeyBits = uint(320)
)

// DiffieHellmanKey is a public/private Diffie-Hellman key pair.
type DiffieHellmanKey struct {
	Private [DiffieHellmanSecretSize]byte
	Public  [DiffieHellmanPublicSize]byte
}

// GenerateDiffieHellmanKey generates a Diffie-Hellman key pair..
func GenerateDiffieHellmanKey() (*DiffieHellmanKey, error) {
	x, err := dh.GeneratePrivateBits(privateKeyBits)
	if err != nil {
		return nil, err
	}
	X, err := dh.Public(x)
	if err != nil {
		return nil, err
	}
	k := new(DiffieHellmanKey)
	bigIntCopy(k.Private[:], x)
	bigIntCopy(k.Public[:], X)
	return k, nil
}

// ComputeSharedSecret computes the shared secret given their public key.
func (k *DiffieHellmanKey) ComputeSharedSecret(pub []byte) ([]byte, error) {
	Y := new(big.Int).SetBytes(pub)
	x := new(big.Int).SetBytes(k.Private[:])
	s, err := dh.DiffieHellman(Y, x)
	if err != nil {
		return nil, err
	}
	b := make([]byte, DiffieHellmanPublicSize)
	bigIntCopy(b, s)
	return b, nil
}

func bigIntCopy(dst []byte, src *big.Int) {
	b := src.Bytes()
	if len(b) > len(dst) {
		panic("integer too big")
	}
	copy(dst, b)
}
